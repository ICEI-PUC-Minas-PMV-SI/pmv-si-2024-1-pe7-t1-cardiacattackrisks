# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zLeXG9k07PR3bvdHH9sZc72QpIhnCyAZ
"""

from google.colab import files
import pandas as pd

# Fazer upload do arquivo
uploaded = files.upload()

# Carregar o dataset
data = pd.read_csv(list(uploaded.keys())[0])
data.head()

from sklearn.preprocessing import LabelEncoder

# Remover colunas não numéricas que provavelmente não são úteis para a predição
data = data.drop(columns=['Patient ID', 'Country', 'Continent', 'Hemisphere'])

# Codificar variáveis categóricas
label_encoders = {}
for column in data.select_dtypes(include=['object']).columns:
    le = LabelEncoder()
    data[column] = le.fit_transform(data[column])
    label_encoders[column] = le

data.head()

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# Separar os dados em características (features) e alvo (target)
X = data.drop(columns=['Heart Attack Risk'])
y = data['Heart Attack Risk']

# Padronizar as características
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Dividir os dados em conjuntos de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# Separar os dados em características (features) e alvo (target)
X = data.drop(columns=['Heart Attack Risk'])
y = data['Heart Attack Risk']

# Padronizar as características
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Dividir os dados em conjuntos de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

from sklearn.ensemble import RandomForestClassifier

# Treinar um modelo Random Forest
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

# Fazer previsões
y_pred = model.predict(X_test)

# Criar a matriz de confusão
cm = confusion_matrix(y_test, y_pred)

# Exibir a matriz de confusão
disp = ConfusionMatrixDisplay(confusion_matrix=cm)
disp.plot(cmap='Blues')
plt.title('Matriz de Confusão')
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Visualização da contagem de risco de ataque cardíaco
plt.figure(figsize=(8, 6))
sns.countplot(x='Heart Attack Risk', data=data, palette='Set2', hue='Heart Attack Risk', dodge=False)
plt.title('Contagem de Risco de Ataque Cardíaco')
plt.xlabel('Risco de Ataque Cardíaco')
plt.ylabel('Contagem')
plt.legend([],[], frameon=False)  # Remove a legenda criada pelo hue
plt.show()

# Visualização de correlação
plt.figure(figsize=(14, 12))
sns.heatmap(data.corr(), annot=True, fmt='.2f', cmap='coolwarm', annot_kws={'size': 10})
plt.title('Mapa de Calor de Correlação')
plt.show()

# Distribuição de algumas variáveis importantes
fig, axes = plt.subplots(1, 2, figsize=(16, 6))

# Distribuição de Idade
sns.histplot(data['Age'], bins=20, kde=True, ax=axes[0], color='skyblue')
axes[0].set_title('Distribuição de Idade')
axes[0].set_xlabel('Idade')
axes[0].set_ylabel('Frequência')

# Distribuição de Colesterol
sns.histplot(data['Cholesterol'], bins=20, kde=True, ax=axes[1], color='salmon')
axes[1].set_title('Distribuição de Colesterol')
axes[1].set_xlabel('Colesterol')
axes[1].set_ylabel('Frequência')

plt.tight_layout()
plt.show()

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt

# Fazer previsões
y_pred = model.predict(X_test)

# Avaliar o modelo
accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred)

# Exibir as métricas de avaliação
metrics = {
    "Acurácia": accuracy,
    "Precisão": precision,
    "Recall": recall,
    "F1 Score": f1
}

metrics_df = pd.DataFrame(metrics, index=[0])
print(metrics_df)

# Visualizar as métricas de avaliação
metrics_df.plot(kind='bar', figsize=(10, 6))
plt.title('Métricas de Avaliação do Modelo')
plt.ylabel('Valores')
plt.xticks(rotation=0)
plt.show()