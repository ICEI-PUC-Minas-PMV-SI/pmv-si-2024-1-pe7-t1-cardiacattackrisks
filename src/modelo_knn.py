# -*- coding: utf-8 -*-
"""Modelo KNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x_LVzQBvnEFzvWOLPDHeIpIQspUQLd0b
"""

from google.colab import files
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px
import geopandas as gpd
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split

from sklearn.naive_bayes import GaussianNB
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import accuracy_score
from sklearn.metrics import roc_curve
from sklearn.metrics import roc_auc_score
from sklearn.metrics import confusion_matrix
from sklearn.model_selection import cross_val_score
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
import xgboost as xgb
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import precision_score

data = pd.read_csv ('heart_attack_prediction_dataset.csv')

# Deletar coluna ID
data = data.drop(columns=['Patient ID'])

# Dados duplicados e nulos

print(f"Total de linhas duplicadas: {data.duplicated().sum()}")
print("---------------")
print(f"Total Valores Nulos        : {data.isnull().sum().sum()}")

# Edição da Pressão Sanguinea

data["Systolic Pressure"] = data["Blood Pressure"].apply(lambda x: x.split("/")[0]).astype(int)
data["Dyastolic Pressure"] = data["Blood Pressure"].apply(lambda x: x.split("/")[1]).astype(int)

# Deletar Blood Pressure
data = data.drop(columns=['Blood Pressure'])

#Redução de casas decimais para uma após a vírgula

pd.set_option('display.precision', 1)

#Transformando dados de 'Diet'

ordinal_map = {'Healthy':2,'Average':1,'Unhealthy':0}
data['Diet'] = data['Diet'].map(ordinal_map)

#Transformando Male = 1 e Female = 0

ordinal_map_sex = {'Male':1, 'Female':0}
data['Sex'] = data['Sex'].map(ordinal_map_sex)

#Treinamento dos dados - KNN

#Selecionando variáveis importantes pro modelo
X = data[['Sex', 'Age', 'Cholesterol', 'Heart Rate','Diabetes', 'Family History','Dyastolic Pressure','Systolic Pressure',
                        'Smoking', 'Obesity','Alcohol Consumption', 'Diet', 'Exercise Hours Per Week',
                        'Previous Heart Problems', 'Medication Use', 'Triglycerides', 'Sleep Hours Per Day']]

y= data['Heart Attack Risk'].values

# 1 - Criando um conjunto de dados pra treinamento e teste
# Test_size=0.2 significa que 20% dos dados serão usados ​​como conjunto de teste, enquanto 80% serão usados ​​como conjunto de treinamento.

X_train, X_test, y_train, y_test = train_test_split(X, y,random_state = 1,test_size=0.2)

# 2 - Uso do StandadScaler como forma de normalizar os dados numa mesa escala pra facilitar análises

sc_X = StandardScaler()
X_train = sc_X.fit_transform(X_train)
X_test = sc_X.transform(X_test)

# 3 - Seleção da quantidade de vizinhos. Usamos quatro valores pra decidir ao final qual é o melhor

classifier_3 = KNeighborsClassifier(n_neighbors=3)
classifier_5 = KNeighborsClassifier(n_neighbors=5)
classifier_7 = KNeighborsClassifier(n_neighbors=7)
classifier_12 = KNeighborsClassifier(n_neighbors=12)

# 4 - Treinando o modelo KNN com os cenários de teste feito no passo 1

classifier_3.fit(X_train, y_train)
classifier_5.fit(X_train, y_train)
classifier_7.fit(X_train, y_train)
classifier_12.fit(X_train, y_train)

# 5 - Para fazer predições dos resultados dos testes

y_pred_3 = classifier_3.predict(X_test)
y_pred_5 = classifier_5.predict(X_test)
y_pred_7 = classifier_7.predict(X_test)
y_pred_12 = classifier_12.predict(X_test)

# 6 - Métricas de performance do modelo KNN
# accuracy_score calcula a precisão do modelo

cm_KNN = confusion_matrix(y_test, y_pred_3)
print (cm_KNN)
print(accuracy_score(y_test, y_pred_3))

cm_KNN = confusion_matrix(y_test, y_pred_5)
print (cm_KNN)
print(accuracy_score(y_test, y_pred_5))

cm_KNN = confusion_matrix(y_test, y_pred_7)
print (cm_KNN)
print(accuracy_score(y_test, y_pred_7))

cm_KNN = confusion_matrix(y_test, y_pred_12)
print (cm_KNN)
print(accuracy_score(y_test, y_pred_12))

cm_KNN = confusion_matrix(y_test, y_pred_5)
acc_KNN = accuracy_score(y_test, y_pred_5)
sns.heatmap(cm_KNN, annot=True, fmt='d', cmap='Reds')
plt.xlabel('Precisão')
plt.ylabel('Atual')
plt.title('Confusion Matrix')
plt.show()

"""**INTERPRETAÇÃO**

Verdadeiros Positivos (142): São indivíduos com previsão correta de
risco de ataque cardíaco.

Verdadeiros Negativos (847): Estes são indivíduos corretamente previstos como não correndo risco de ataque cardíaco.

Falsos Positivos (295): São indivíduos com previsão incorreta de risco de ataque cardíaco.

Falsos Negativos (469): São indivíduos com previsão incorreta de não correrem risco de ataque cardíaco.

A precisão de 0,564 indica que quando o modelo prevê que um indivíduo corre risco de ter um ataque cardíaco, **ele está correto em cerca de 56,4% das vezes.**
"""

